create table content.service (
  id integer primary key generated always as identity,
  name text not null
);

insert into content.service (name) values ('auth');

create table content.error (
  id integer primary key generated always as identity,
  -- docs_id is an ID that can be generated by docs from existing information,
  -- so we don't need to sync the primary key back to the docs repo. We still
  -- need the primary key for sorting purposes.
  docs_id text not null unique,
  service_id integer references content.service(id) not null on delete restrict,
  code text not null,
  http_status_code integer,
  message text,
  checksum text not null,
  -- workflows that sync this table need to validate unchanged rows, so that
  -- other rows can be deleted
  validated_by uuid,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  deleted_at timestamp with time zone,
  deleted boolean default false
);

alter table content.error
enable row level security;

create trigger trg_content_error_set_deleted_flag
before insert or update
on content.error
for each row
execute function internal.set_deleted_flag();

create trigger trg_content_error_set_updated_time
before insert or update
on content.error
for each row
execute function internal.set_updated_time();

grant select on content.error (
  id,
  docs_id,
  service_id,
  code,
  http_status_code,
  message,
  deleted
) to anon, authenticated;

grant insert on content.error (
  docs_id,
  service_id,
  code,
  http_status_code,
  message,
) to anon, authenticated;

grant update on content.error (
  service_id,
  code,
  http_status_code,
  message
) to anon, authenticated;

create table content.troubleshooting (
  id uuid primary key default uuid_generate_v4(),
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now(),
  deleted_at timestamp with time zone
);

grant select on content.troubleshooting (
  id,
  created_at,
  updated_at,
  deleted_at
) to anon;
